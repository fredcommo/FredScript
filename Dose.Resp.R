Dose.Resp <- function(Dose, Resp, Blank=0, T0=0){


ctrl.index <- which(Dose==0)
x <- Dose[-ctrl.index]

correct.resp <- Resp[-ctrl.index,] - T0
ctrl <- mean(as.numeric(Resp[ctrl.index,]-T0))

y <- mean(as.data.frame(t(correct.resp/ctrl)))
sdev <- sd(as.data.frame(t(correct.resp/ctrl)))


# Avec nlm
	# Fonction logistique 4P
		nlm.fit <- function(bottom, top, xmid, scal, X){
			Y.fit <-bottom+(top-bottom)/(1+10^((xmid-X)*scal))
			return(Y.fit)
			}

	# Fonction sce (somme carré résidus) avec pondérations
		sce <- function(param, X, yobs, Weights) {
			bottom <- param[1]
			top <- param[2]
			xmid <- param[3]
			scal <- param[4]
			ytheo <- nlm.fit(bottom, top, xmid, scal, X)
			#residus <- (yobs - ytheo)^2
			#Weights <- sqrt(1/(residus))
			return(sum(Weights*(yobs - ytheo)^2))
			}

	# initialisation des valeurs
		bottom.ini = min(y); min(y)
		top.ini = max(y); max(y)
		xmid.ini = (max(x)+min(x))/2; xmid.ini
		#z <- y/(max(y)*1.05)
		z <- y			# si y = prop
		scal.ini = 1/coef(lm(x~log(z/(1.005-z))))[2]
		scal.ini <- as.numeric(scal.ini); scal.ini
		weights <- sqrt(z*(1-z))	#rep(1, length(x))

		init <- c(bottom=bottom.ini, top=top.ini, xmid=xmid.ini, scal=scal.ini)
		best<-nlm(f = sce, p = init, X = x, yobs = y, Weights=weights)						# calcul des paramètres

	# Récupération des paramètres
		best.bottom <- best$estimate[1]
		best.top <- best$estimate[2]
		best.xmid<- best$estimate[3]
		best.scal <- best$estimate[4]

	# Estimation des valeurs
		newX <- seq(min(x), max(x)*2, length=100)						
		Y.best <- nlm.fit(best.bottom, best.top, best.xmid, best.scal, newX)

			# coordonnées du pt d'inflexion
				Xflex = best.xmid + (1/best.scal)*log10(1)
				Yflex = best.bottom + (best.top - best.bottom)*(1/(1+1))^1

			# coordonnées du pt rep = 0.5
				# Y50 = (max(y) + min(y))/2
				# Y50 = (best.bottom + best.top)/2
				Y50 = 0.5
				X50 = best.xmid - 1/best.scal*log10(((best.top - best.bottom)/(Y50 - best.bottom))^(1/1)-1)
				# X50 = best.xmid - 1/best.scal*log10((1/(Y50))^(1/1)-1)								# top = 1, bottom = 0

			# pente au pt d'inflexion
				B = best.bottom + (best.top - best.bottom)*log(10)*(best.scal)*(1/(1+1))^(1+1); B	# + best.bottom 							# 5P	 	pour d=1, (d/(d+1))^(d+1) = 1/4
				# B = log(10)*(best.scal)*(1/(1+1))^(1+1); B								# top = 1, bottom = 0
				A = Y50  - B*(X50); A													# 5P		pour d=1, (d/(d+1))^d = 1/2
				print(c(bottom = best.bottom, 
						top = best.top,
						xmid = best.xmid,
						scal = best.scal,
						Xflex = Xflex, Yflex = Yflex,
						X50 = X50, Y50 = Y50))

			# Intervalle IC X50
				ytheo <- nlm.fit(best.bottom, best.top, best.xmid, best.scal, x)
				Q <- sum((y - ytheo)^2)
				S2 <- Q/(length(x)-2)
				sd <- sqrt(S2)

				MC.X50 <- rep(0, 10000)

				for (i in 1:10000)
					MC.X50[i] <- best.xmid - 1/best.scal*log10(((best.top - best.bottom)/(Y50+rnorm(1,0,sd) - best.bottom))^(1/1)-1)

				q.X50 <- quantile(MC.X50, probs=c(0.025, 0.975), na.rm=T)
				q.X50; 10^(q.X50)



	# Représentations graphiques
		plot(y~x, pch = 20, cex = 1.25, col = "blue", xlim=range(min(newX),max(newX)), ylim = range(0, 1))

		for (i in 1:length(y)){
			pas <- (max(x)+min(x))/2*0.05
			segments(x0=x[i], y0=y[i]-sdev[i], x1=x[i], y1=y[i]+sdev[i])
			segments(x0=x[i]-pas, y0=y[i]-sdev[i], x1=x[i]+pas, y1=y[i]-sdev[i])
			segments(x0=x[i]-pas, y0=y[i]+sdev[i], x1=x[i]+pas, y1=y[i]+sdev[i])
			}

		lines(Y.best~newX, col = "orangered", lwd = 2)
		segments(x0 = X50, y0 = 0, x1 = X50, y1 = Y50, lty = 3)
		segments(x0 = 0, y0 = Y50, x1 = X50, y1 = Y50, lty = 3)

}

# Exemple de courbe de survie cell

	# illustration de l'incohérence
plot(y~x, pch = 20, cex = 1.25, col = "blue", ylim = range(0,1), xlab="Log(drug)", ylab="Surv in %")
abline(h=c(0,1), lty=3)
abline(lm(y~x), lwd=2, col="orangered")
legend(x=1.5, y=0.9, legend=c("Obs","Reg.Lin"), pch=c(20,-1), lty=c(0,1), lwd=2, cex = 1.25, col=c("blue","orangered"), bty="n")

	# illustration de la transfo logit
z <- log(y/(1-y))
plot(z~x, pch = 20, cex = 1.25, col = "blue", xlab="Log(drug)", ylab="logit(Rep)")
abline(lm(z~x), lwd=2, col="orangered")
legend(x=1.5, y=0.9, legend=c("logit","Reg.Lin"), pch=c(20,-1), lty=c(0,1), lwd=2, cex = 1.25, col=c("blue","orangered"), bty="n")

	# illustration de la régression logistique
plot(y~x, pch = 20, cex = 1.25, col = "blue", ylim = range(0,1), xlab="Log(drug)", ylab="Surv in %")
abline(h=c(0,1), lty=3)
lines(Y.best~newX, col = "orangered", lwd = 2)
legend(x=1.1, y=0.9, legend=c("Obs","Reg.Logistique"), pch=c(20,-1), lty=c(0,1), lwd=2, cex = 1.25, col=c("blue","orangered"), bty="n")

	# IC X50
ytheo <- nlm.fit(best.bottom, best.top, best.xmid, best.scal, x)
Q <- sum((y - ytheo)^2)
S2 <- Q/(length(x)-2)
sd <- sqrt(S2)

MC.X50 <- rep(0, 10000)

for (i in 1:10000)
MC.X50[i] <- best.xmid - 1/best.scal*log10(((best.top - best.bottom)/(Y50+rnorm(1,0,sd) - best.bottom))^(1/1)-1)

#plot(density(MC.X50,na.rm=T))
q.X50 <- quantile(MC.X50, probs=c(0.025, 0.975), na.rm=T)
q.X50; 10^(q.X50)

z <- log(y/(1-y))
Q <- sum(resid(lm(z~x))^2)
S2 <- Q/(length(x)-2)
xbar <- mean(x)
Sxx <- sum((x-xbar)^2)
Vlog <- (S2/B^2)*(1/length(y) + (X50 - xbar)^2/Sxx)
SE <- sqrt(Vlog)
exp(X50 - X50*2.3*SE^2); exp(X50 + X50*2.3*SE^2)
exp(X50)

segments(x0=q.X50[1], y0=0.5, x1=q.X50[2], y1=0.5, lwd=2)
segments(x0=q.X50[1], y0=0.45, x1=q.X50[1], y1=0.55)
segments(x0=q.X50[2], y0=0.45, x1=q.X50[2], y1=0.55)

# Ajouter l'intervalle de confiance sur la courbe